<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Threshold Sigil</title>
    <style>
      :root {
        color-scheme: dark;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background: #0b0c12;
        color: #e8e7e3;
        font-family: "Inter", "Helvetica Neue", Arial, sans-serif;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        position: relative;
      }

      header {
        padding: 0.75rem 1rem;
        opacity: 0.8;
        letter-spacing: 0.04em;
        font-size: 0.9rem;
        text-transform: uppercase;
      }

      canvas {
        flex: 1;
        width: 100%;
        height: 100%;
        min-height: 0;
        display: block;
      }

      .legend {
        position: absolute;
        bottom: 0.75rem;
        right: 1rem;
        background: rgba(10, 12, 18, 0.78);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        padding: 0.5rem 0.75rem;
        font-size: 0.8rem;
        line-height: 1.35;
        max-width: min(420px, 90vw);
        word-break: break-word;
        backdrop-filter: blur(4px);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.4);
        pointer-events: none;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
  </head>
  <body>
    <header>Threshold Signal // minimal generative sigil</header>
    <p class="sr-only" id="sigil-desc">
      A looping generative sigil radiates lines from a soft center, pulsing with
      color shifts defined by quiet parameters.
    </p>
    <canvas id="sigil" aria-describedby="sigil-desc"></canvas>
    <div class="legend" id="legend"></div>

    <script>
      // Minimal configuration with URL overrides for quick experimentation.
      const defaults = {
        background: "#0b0c12",
        line: "#7fffd4",
        accent: "#ff6bcb",
        iterations: 144,
        orbitRadius: 0.32,
        noise: 0.38,
        speed: 0.45,
      };

      const params = new URLSearchParams(window.location.search);

      function parseColor(input, fallback) {
        if (!input || typeof input !== "string") return fallback;
        const clean = input.trim().replace(/^#/, "");
        const isValidHex = /^[0-9a-fA-F]+$/.test(clean);
        if (!isValidHex || (clean.length !== 3 && clean.length !== 6)) {
          return fallback;
        }
        const expanded =
          clean.length === 3
            ? clean
                .split("")
                .map((char) => `${char}${char}`)
                .join("")
            : clean;
        return `#${expanded.toLowerCase()}`;
      }

      function parseNumber(input, fallback, bounds = {}) {
        if (input === null || input === undefined || input === "") {
          return fallback;
        }
        const parsed = Number(input);
        if (!Number.isFinite(parsed)) return fallback;
        const { min, max } = bounds;
        let clamped = parsed;
        if (typeof min === "number") clamped = Math.max(min, clamped);
        if (typeof max === "number") clamped = Math.min(max, clamped);
        return clamped;
      }

      const config = {
        background: parseColor(params.get("background"), defaults.background),
        line: parseColor(params.get("line"), defaults.line),
        accent: parseColor(params.get("accent"), defaults.accent),
        iterations: Math.round(
          parseNumber(params.get("iterations"), defaults.iterations, {
            min: 24,
            max: 720,
          }),
        ),
        orbitRadius: parseNumber(
          params.get("orbitRadius"),
          defaults.orbitRadius,
          { min: 0, max: 1 },
        ),
        noise: parseNumber(params.get("noise"), defaults.noise, {
          min: 0,
          max: 1,
        }),
        speed: parseNumber(params.get("speed"), defaults.speed, {
          min: 0,
          max: 3,
        }),
      };

      const canvas = document.getElementById("sigil");
      const ctx = canvas.getContext("2d");
      const legend = document.getElementById("legend");
      let dpr = window.devicePixelRatio || 1;

      function resize() {
        dpr = window.devicePixelRatio || 1;
        const { width, height } = canvas.getBoundingClientRect();
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      let frame = 0;
      const dots = [];

      function seedDots(count) {
        const total = Math.max(1, count);
        dots.length = 0;
        for (let i = 0; i < total; i++) {
          const theta = (i / total) * Math.PI * 2;
          const radius =
            Math.sin(theta * 3 + i * 0.03) * 0.25 + config.orbitRadius;
          dots.push({ theta, radius, drift: Math.random() * Math.PI * 2 });
        }
      }

      function lerp(a, b, t) {
        return a + (b - a) * t;
      }

      function loop() {
        const w = canvas.width / dpr;
        const h = canvas.height / dpr;
        ctx.save();
        ctx.globalAlpha = 0.08;
        ctx.fillStyle = config.background;
        ctx.fillRect(0, 0, w, h);
        ctx.restore();

        const cx = w / 2;
        const cy = h / 2;
        const scale = Math.min(w, h) * 0.45;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(Math.sin(frame * 0.001) * 0.03);

        dots.forEach((dot, i) => {
          const wobble = Math.sin(frame * 0.002 + dot.theta * 2) * config.noise;
          const r = lerp(dot.radius, dot.radius + wobble * 0.1, 0.6) * scale;
          const a =
            dot.theta +
            Math.sin(dot.drift + frame * 0.003) * config.noise * 0.35;
          const x = Math.cos(a) * r;
          const y = Math.sin(a) * r;

          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(x, y);
          ctx.strokeStyle = i % 9 === 0 ? config.accent : config.line;
          ctx.lineWidth = i % 18 === 0 ? 2.25 : 1.1;
          ctx.globalAlpha = 0.9;
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(x, y, 2.4, 0, Math.PI * 2);
          ctx.fillStyle = i % 9 === 0 ? config.accent : config.line;
          ctx.globalAlpha = 0.85;
          ctx.fill();
        });

        ctx.restore();
        frame += config.speed;
        requestAnimationFrame(loop);
      }

      function updateLegend() {
        legend.textContent = `bg ${config.background}  |  line ${config.line}  |  accent ${config.accent}  |  iterations ${config.iterations}  |  orbit ${config.orbitRadius.toFixed(2)}  |  noise ${config.noise.toFixed(2)}  |  speed ${config.speed.toFixed(2)}`;
      }

      window.addEventListener("resize", resize);
      resize();
      seedDots(config.iterations);
      updateLegend();
      ctx.fillStyle = config.background;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      requestAnimationFrame(loop);
    </script>
  </body>
</html>
